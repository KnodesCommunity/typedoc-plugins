import { isString } from 'lodash';

interface ISourceNode {
	name: string;
	path?: {
		urlFragment?: string;
		fs?: string;
		virtual?: string;
	};
	attributes?: Record<string, unknown>;
	content?: string;
}
export type SourceNode =
	& ISourceNode
	& (
		| {content?: undefined; path?: {fs?: string; urlFragment?: string}}
		| {content: string; path: {fs: string; virtual: string}} );
export type ModuleSourceNode = SourceNode & {path: {fs: string; virtual: string}}
export interface INodeInParent {
	node: SourceNode;
	parents: SourceNode[];
}

export interface IBaseRawNode {
	loader?: string;
}
export type UnknownNode = Record<string, any>

export type NodePath = ReadonlyArray<string | number>;
export interface ICheckConfigContext {
	recurse: ( node: IBaseRawNode, path: NodePath ) => void;
	path: NodePath;
}
export interface IRegisterNodeContext<T = unknown> {
	recurse: ( node: IBaseRawNode, parents: SourceNode[], data: T ) => NodeGenerator;
	data?: T;
	parents: SourceNode[];
}
export type NodeGenerator = Generator<INodeInParent, void, undefined>
export interface INodeLoader<T extends IBaseRawNode, TRegisterData = unknown> {
	/**
	 * Check if the node can be loaded by this loader.
	 *
	 * @param rawNode - The node to check.
	 * @returns `true` if this loader can be used to load this node.
	 */
	canHandle( rawNode: UnknownNode ): boolean;

	/**
	 * Asserts that the given node has a valid config for this loader.
	 *
	 * @param rawNode - The node to check.
	 * @param context - The check context. Contains an utility to recurse, and the current path.
	 */
	checkConfigNode( rawNode: UnknownNode, context: ICheckConfigContext ): asserts rawNode is T;

	/**
	 * Expand & yield menus & pages from the given node.
	 *
	 * @param rawNode - The node to register.
	 * @param context - The context of the current collection. Contains an utility to recurse, a list of parent nodes, and an arbitrary data store generated by parents.
	 * @yields a list of nodes along with their parents
	 */
	collectNodes( rawNode: T, context: IRegisterNodeContext<TRegisterData> ): NodeGenerator;
}
export type NodeForLoader<T> = T extends INodeLoader<infer TNode> ? TNode : never;

export const nodeHasFile = ( node: SourceNode ): node is SourceNode & {path: {fs: string}} => isString( node.path?.fs );

export const nodeHasVirtual = ( node: SourceNode ): node is SourceNode & {path: {virtual: string}} => isString( node.path?.virtual );
