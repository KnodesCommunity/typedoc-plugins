import assert from 'assert';
import { format } from 'util';

import { LoDashStatic, castArray, isArray, isBoolean, isFunction, isNumber, isObject, isString, last, template } from 'lodash';

import { IPluginComponent, PluginAccessor, getPlugin } from '@knodes/typedoc-pluginutils';
import { basename, dirname, normalize, relative, resolve } from '@knodes/typedoc-pluginutils/path';

import type { PagesPlugin } from '../../plugin';
import { IBaseRawNode, ICheckConfigContext, INodeLoader, IRegisterNodeContext, ModuleSourceNode, NodeGenerator, UnknownNode } from './nodes';
import { GlobMatch, doesMatch, globMatch, isValidGlobMatch } from './utils';

const imports: Omit<TemplateNodeLoader.ITemplateContext, '_'> = {
	path: {
		dirname,
		basename,
		relative,
	},
};

const expandNode = <T>( value: T, match: TemplateNodeLoader.ITemplateMatch ): T => {
	if( isString( value ) ) {
		return template( value, { variable: 'match', imports } )( match ) as any;
	} else if( isArray( value ) ){
		return value.map( v => expandNode( v, match ) ) as any;
	} else if( isObject( value ) ) {
		return Object.fromEntries( Object.entries( value ).map( ( [ k, v ] ) => [ k, expandNode( v, match ) ] ) ) as any;
	} else if( isBoolean( value ) || isNumber( value ) ){
		return value;
	} else {
		throw new Error( format( 'Unhandled value %O', value ) );
	}
};

// @LEGACY -- Remove @experimental for v0.24
/**
 * @experimental
 */
export class TemplateNodeLoader implements IPluginComponent<PagesPlugin>, INodeLoader<TemplateNodeLoader.IRawNode, TemplateNodeLoader.ITemplateMatch[]> {
	public constructor( private readonly _parent: PluginAccessor<PagesPlugin>, public readonly plugin = getPlugin( _parent ) ) {}

	/**
	 * Check if the node can be loaded by this loader.
	 *
	 * @param rawNode - The node to check.
	 * @returns `true` if this loader can be used to load this node.
	 */
	public canHandle( rawNode: UnknownNode ): boolean {
		return 'loader' in rawNode && rawNode.loader === 'template';
	}

	/**
	 * Asserts that the given node has a valid config for this loader.
	 *
	 * @param rawNode - The node to check.
	 * @param context - The check context. Contains an utility to recurse, and the current path.
	 */
	public checkConfigNode( rawNode: UnknownNode, { recurse, path }: ICheckConfigContext ): asserts rawNode is TemplateNodeLoader.IRawNode {
		assert(
			'match' in rawNode && isValidGlobMatch( rawNode.match ),
			format( 'Node %O should have a `match` string (or string array)', rawNode ) );

		assert(
			'template' in rawNode && ( ( isArray( rawNode.template ) && rawNode.template.every( isObject ) ) || isObject( rawNode.template ) || isFunction( rawNode.template ) ),
			format( 'Node %O should have a `template` object, array of objects, or function', rawNode ) );
		if( !isFunction( rawNode.template ) ){
			castArray( rawNode.template ).forEach( ( c, i ) => recurse( c, [ 'children', i ] ) );
		}

		if( 'modules' in rawNode ){
			assert( path.length === 2, format( 'Node %O has "modules" property, which can only appear in top-level node.', rawNode ) );
		}
	}

	/**
	 * Expand & yield menus & pages from the given node.
	 *
	 * @param rawNode - The node to register.
	 * @param context - The context of the current collection. Contains an utility to recurse, a list of parent nodes, and an arbitrary data store generated by parents.
	 * @yields a list of nodes along with their parents
	 */
	public *collectNodes( rawNode: TemplateNodeLoader.IRawNode, { parents, data, recurse }: IRegisterNodeContext<TemplateNodeLoader.ITemplateMatch[]> ): NodeGenerator {
		assert( parents[0].path );
		if( rawNode.modules ){
			assert( isString( parents[0].path.virtual ) );
			if( !doesMatch( parents[0].path.virtual, rawNode.modules ) ){
				return;
			}
		}
		const rootPath = parents[0].path.fs;
		assert( isString( rootPath ) );
		const dataDefaulted = data ?? [];
		const allMatched = globMatch( rawNode.match, { from: rootPath } )
			.map( m => ( {
				module: last( parents ),
				from: rootPath,
				match: normalize( m ),
				fullPath: resolve( rootPath, m ),
				prev: [ ...dataDefaulted ],
			} as TemplateNodeLoader.ITemplateMatch ) );
		for( const matched of allMatched ) {
			yield* this._expandTemplateForMatch( rawNode.template, matched, function*( subNode ){
				yield* recurse( subNode, parents, [ ...dataDefaulted, matched ] );
			} );
		}
	}

	/**
	 * Expand the given template & recurse on the expanded nodes.
	 *
	 * @param tpl - The template to expand.
	 * @param match - The match informations.
	 * @param recurse - A function to call with expanded template to generate actual nodes.
	 * @yields nodes for each template matches.
	 */
	private *_expandTemplateForMatch(
		tpl: TemplateNodeLoader.IRawNode['template'],
		match: TemplateNodeLoader.ITemplateMatch,
		recurse: ( node: IBaseRawNode ) => NodeGenerator,
	): NodeGenerator {
		if( isFunction( tpl ) ){
			const tplRes = tpl( match );
			for( const tplResIter of castArray( tplRes ) ){
				yield* recurse( tplResIter );
			}
			return;
		}
		const templateResults = castArray( tpl ).map( t => expandNode( t, match ) );
		for( const templateResult of templateResults ){
			yield* recurse( templateResult );
		}
	}
}
type AnyChildNode = IBaseRawNode & UnknownNode;
export namespace TemplateNodeLoader {
	export interface IRawNode extends IBaseRawNode {
		loader:'template';
		/**
		 * A path or list of paths with which to expand the {@link template}.
		 */
		match: GlobMatch;
		/**
		 * A function, node or list of nodes expanded with the matched paths.
		 */
		template: AnyChildNode[] | AnyChildNode | ( ( match: ITemplateMatch ) => ( AnyChildNode | AnyChildNode[] ) );
		/**
		 * A list of patterns to filter modules.
		 */
		modules?: GlobMatch;
	}
	export interface ITemplateContext {
		/**
		 * Lodash functions.
		 *
		 * @see https://lodash.com/docs/
		 */
		_: LoDashStatic;
		/**
		 * A subset of `node:path` package. Each methods are normalized, eg. `\` are replaced with `/` no matter the operating system
		 */
		path: Pick<typeof import( '@knodes/typedoc-pluginutils/path' ), 'dirname' | 'basename' | 'relative'>;
	}
	export interface ITemplateMatch {
		/**
		 * The module informations where the match was found.
		 */
		module: ModuleSourceNode;
		/**
		 * The path within the module from where the `match` was executed.
		 */
		from: string;
		/**
		 * The actual glob matched.
		 */
		match: string;
		/**
		 * The full path, usually <code>{@link from}/{@link match}</code>.
		 */
		fullPath: string;
		/**
		 * The ancestor matches (in case of nested templates).
		 *
		 * @experimental Nested templates are poorly tested and might have unexpected behaviors. Yet, they **should** work.
		 * If you use nested templates & encounter a problem, feel free to open an issue so that I can have real use cases.
		 */
		prev: ITemplateMatch[];
	}
}

