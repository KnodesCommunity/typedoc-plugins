import assert from 'assert';
import { basename, dirname, relative, resolve } from 'path';
import { format } from 'util';

import { LoDashStatic, castArray, isArray, isBoolean, isFunction, isNumber, isObject, isString, last, template } from 'lodash';
import { normalizePath } from 'typedoc';

import { IPluginComponent, PluginAccessor, getPlugin } from '@knodes/typedoc-pluginutils';

import type { PagesPlugin } from '../../plugin';
import { IBaseRawNode, ICheckConfigContext, INodeLoader, IRegisterNodeContext, NodeGenerator, SourceNode, UnknownNode } from './nodes';
import { GlobMatch, doesMatch, globMatch, isValidGlobMatch } from './utils';

export interface ITemplateContext {
	_: LoDashStatic;
	path: Pick<typeof import( 'path' ), 'dirname' | 'basename' | 'relative'>;
}
const imports: Omit<ITemplateContext, '_'> = {
	path: {
		dirname: ( ...args: Parameters<typeof dirname> ) => normalizePath( dirname( ...args ) ),
		basename: ( ...args: Parameters<typeof basename> ) => normalizePath( basename( ...args ) ),
		relative: ( ...args: Parameters<typeof relative> ) => normalizePath( relative( ...args ) ),
	},
};

const expandNode = <T>( value: T, match: TemplateNodeLoader.ITemplateMatch ): T => {
	if( isString( value ) ) {
		return template( value, { variable: 'match', imports } )( match ) as any;
	} else if( isArray( value ) ){
		return value.map( v => expandNode( v, match ) ) as any;
	} else if( isObject( value ) ) {
		return Object.fromEntries( Object.entries( value ).map( ( [ k, v ] ) => [ k, expandNode( v, match ) ] ) ) as any;
	} else if( isBoolean( value ) || isNumber( value ) ){
		return value;
	} else {
		throw new Error( format( 'Unhandled value %O', value ) );
	}
};

// @LEGACY -- Remove @experimental for v0.24
/**
 * @experimental
 */
export class TemplateNodeLoader implements IPluginComponent<PagesPlugin>, INodeLoader<TemplateNodeLoader.IRawNode, TemplateNodeLoader.ITemplateMatch[]> {
	public constructor( private readonly _parent: PluginAccessor<PagesPlugin>, public readonly plugin = getPlugin( _parent ) ) {}

	/**
	 * Check if the node can be loaded by this loader.
	 *
	 * @param rawNode - The node to check.
	 * @returns `true` if this loader can be used to load this node.
	 */
	public canHandle( rawNode: UnknownNode ): boolean {
		return 'loader' in rawNode && rawNode.loader === 'template';
	}

	/**
	 * Asserts that the given node has a valid config for this loader.
	 *
	 * @param rawNode - The node to check.
	 * @param context - The check context. Contains an utility to recurse, and the current path.
	 */
	public checkConfigNode( rawNode: UnknownNode, { recurse, path }: ICheckConfigContext ): asserts rawNode is TemplateNodeLoader.IRawNode {
		assert(
			'match' in rawNode && isValidGlobMatch( rawNode.match ),
			format( 'Node %O should have a `match` string (or string array)', rawNode ) );

		assert(
			'template' in rawNode && ( ( isArray( rawNode.template ) && rawNode.template.every( isObject ) ) || isObject( rawNode.template ) || isFunction( rawNode.template ) ),
			format( 'Node %O should have a `template` object, array of objects, or function', rawNode ) );
		if( !isFunction( rawNode.template ) ){
			castArray( rawNode.template ).forEach( ( c, i ) => recurse( c, [ 'children', i ] ) );
		}

		if( 'modules' in rawNode ){
			assert( path.length === 2, format( 'Node %O has "modules" property, which can only appear in top-level node.', rawNode ) );
		}
	}

	/**
	 * Expand & yield menus & pages from the given node.
	 *
	 * @param rawNode - The node to register.
	 * @param context - The context of the current collection. Contains an utility to recurse, a list of parent nodes, and an arbitrary data store generated by parents.
	 * @yields a list of nodes along with their parents
	 */
	public *collectNodes( rawNode: TemplateNodeLoader.IRawNode, { parents, data, recurse }: IRegisterNodeContext<TemplateNodeLoader.ITemplateMatch[]> ): NodeGenerator {
		assert( parents[0].path );
		if( rawNode.modules ){
			assert( isString( parents[0].path.virtual ) );
			if( !doesMatch( parents[0].path.virtual, rawNode.modules ) ){
				return;
			}
		}
		const rootPath = parents[0].path.fs;
		assert( isString( rootPath ) );
		const dataDefaulted = data ?? [];
		const allMatched = globMatch( rawNode.match, { from: rootPath } )
			.map( m => ( {
				module: last( parents ),
				from: rootPath,
				match: normalizePath( m ),
				fullPath: normalizePath( resolve( rootPath, m ) ),
				prev: [ ...dataDefaulted ],
			} as TemplateNodeLoader.ITemplateMatch ) );
		for( const matched of allMatched ) {
			yield* this._expandTemplateForMatch( rawNode.template, matched, function*( subNode ){
				yield* recurse( subNode, parents, [ ...dataDefaulted, matched ] );
			} );
		}
	}

	/**
	 *
	 * @param tpl
	 * @param match
	 * @param recurse
	 */
	private *_expandTemplateForMatch(
		tpl: TemplateNodeLoader.IRawNode['template'],
		match: TemplateNodeLoader.ITemplateMatch,
		recurse: ( node: IBaseRawNode ) => NodeGenerator,
	): NodeGenerator {
		if( isFunction( tpl ) ){
			const tplRes = tpl( match );
			yield* castArray( tplRes ).map( node => ( { node, parents: [] } ) );
			return;
		}
		const templateResults = castArray( tpl ).map( t => expandNode( t, match ) );
		for( const templateResult of templateResults ){
			yield* recurse( templateResult );
		}
	}
}
export namespace TemplateNodeLoader {
	export interface IRawNode extends IBaseRawNode {
		loader:'template';
		/**
		 * A path or list of paths with which to expand the {@link template}.
		 */
		match: GlobMatch;
		/**
		 * A function, node or list of nodes expanded with the matched paths.
		 */
		template: Array<IBaseRawNode & UnknownNode> | ( IBaseRawNode & UnknownNode ) | ( ( match: ITemplateMatch ) => ( SourceNode | SourceNode[] ) );
		/**
		 * A list of patterns to filter modules.
		 */
		modules?: GlobMatch;
	}
	export interface ITemplateMatch {
		/** The path from where the `match` was matched. */
		from: string;
		/** The actual glob matched. */
		match: string;
		/** The full path, usually `${{@link from}}/${{@link match}}`. */
		fullPath: string;
		/** The ancestor matches. */
		prev: ITemplateMatch[];
	}
}

